#!/usr/bin/env ruby
require 'rubygems'
require 'optparse'
require 'rbconfig'
require 'open-uri'
require 'imgkit/configuration'
require 'imgkit/version'
require 'json'

GOOGLE_CODE_URL = ENV['GOOGLE_CODE_URL'] || "http://code.google.com/p/wkhtmltopdf/downloads/list?can=1"

#https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.0/wkhtmltox-win32_0.12.0-03c001d.exe
#https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.0/wkhtmltox-win64_0.12.0-03c001d.exe
#https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.0/wkhtmltox-linux-i386_0.12.0-03c001d.tar.xz


def detect_architecture
  case arch = RbConfig::CONFIG['arch']
  when /x86_64-linux/i
    'linux-amd64'
  when /linux/i
    'linux-i386'
  when /darwin/i
    'OSX'
  else
    cant_find_binaries(arch)
  end
end

def cant_find_binaries(arch)
  puts "Sorry, I couldn't find the binary for your architecture (#{arch}) \n  at #{GOOGLE_CODE_URL}"
  puts "Please go to that page, unzip the appropriate binary, and install"
  exit(1)
end

GITHUB_API='application/vnd.github.v3+json'
GITHUB_RELEASES='https://api.github.com/repos/wkhtmltopdf/wkhtmltopdf/releases'

def get_releases
  releases = JSON.load(open(GITHUB_RELEASES, {'Accept' => GITHUB_API}))

  # Pluck out just the field we need
  releases.map do |r|
    { 'name'   => r['name'],
      'assets' => r['assets'].map do |a|
        { 'name' => a['name'], 'url' => a['url'] }
      end
    }
  end
end

def find_asset(releases, architecture)
  asset = nil
  release = releases.find do |r|
    asset = r['assets'].find do |a|
      puts "Checking if #{a['name']} =~ #{architecture}"
      a['name'] =~ Regexp.new(architecture)
    end
  end
  [ release, asset ]
end

def download_asset(asset)
  filename = File.basename(asset['name'])
  puts "Fetching #{asset['url']} to #{filename}..."
  File.open(filename, 'w') do |f|
    f.write(open(asset['url'], {'Accept' => 'application/octet-stream'}).read)
  end
  puts "Finished downloading!"
  filename
end

def install(download, install_to)
  puts "Installing #{download} to #{install_to}"
  if download =~ /.tar.bz2$/
    `tar xvf #{download}`
    `mv wkhtmltoimage #{install_to}`
  else
    `mv #{download} #{install_to}`
  end
  `chmod +x #{install_to}`
end

@command = Proc.new { puts "Nothing to do: use --help"}

OptionParser.new do |parser|
  parser.banner = "IMGKit\n\nOptions are:"

  parser.on("--install-wkhtmltoimage", "Install wkhtmltoimage binaries (TO=/usr/local/bin ARCHITECTURE=i386)") do
    @command = Proc.new do
      architecture = ENV['ARCHITECTURE'] || detect_architecture
      install_to = ENV['TO'] ? ENV['TO']+'/wkhtmltoimage' : IMGKit.configuration.wkhtmltoimage

      Dir.chdir '/tmp'
      releases = get_releases
      puts "Available releases: #{releases.map {|r| r['name']}.join(', ')}"
      release, asset = find_asset(releases, architecture)
      if asset
        puts "Found a build of #{release['name']} for our platform: #{asset['name']}"
        file = download_asset(asset)
        # TODO install(file, to)
      else
        puts "Could not find a release built for our architecture!"
        exit 1
      end
    end
  end

  parser.on("--version", "Show Version.") do
    @command = Proc.new do
      puts IMGKit::VERSION
    end
  end

  parser.on("-h", "--help", "Show this.") { puts parser; exit }
end.parse!

@command.call
